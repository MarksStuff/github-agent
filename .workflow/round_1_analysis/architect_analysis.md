# Architect Analysis

**Feature**: # Feature: 1. Document Symbol Hierarchy
**Date**: 2025-09-07T17:48:59.031965
**Agent**: architect

## Analysis

## Architecture Analysis for Document Symbol Hierarchy Feature

### 1. Existing System Integration

**Modules to Modify:**
- `simple_lsp_client.py:28-422` - Add new `get_document_symbols()` method following existing pattern
- `codebase_tools.py:61-67` - Register new `get_document_symbols` tool in TOOL_HANDLERS mapping
- `symbol_storage.py:88-202` - Extend AbstractSymbolStorage with document symbol methods
- `symbol_storage.py:204-718` - Implement new methods in SQLiteSymbolStorage

**Classes to Extend:**
- `SimpleLSPClient` - Already handles LSP requests via subprocess pattern
- `CodebaseTools` - Central tool registry for MCP exposure
- `Symbol` dataclass at `symbol_storage.py:40-63` - Add parent_id, end_line, end_column fields

**Existing Patterns to Reuse:**
- Subprocess LSP pattern from `simple_lsp_client.py:165-254` (get_references implementation)
- Retry logic from `symbol_storage.py:281-304` (_execute_with_retry)
- Tool handler pattern from `codebase_tools.py:447-495` (search_symbols)

### 2. Data Architecture

**Persistence Strategy:**
- **Primary Storage**: Extend SQLite database with new `document_symbols` table
- **Schema Design**:
  ```sql
  CREATE TABLE document_symbols (
      id INTEGER PRIMARY KEY,
      file_path TEXT NOT NULL,
      repository_id TEXT NOT NULL,
      symbol_name TEXT NOT NULL,
      symbol_kind TEXT NOT NULL,
      start_line INTEGER NOT NULL,
      start_column INTEGER NOT NULL,
      end_line INTEGER NOT NULL,
      end_column INTEGER NOT NULL,
      parent_id INTEGER,
      detail TEXT,
      file_version TEXT NOT NULL,
      extracted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (parent_id) REFERENCES document_symbols(id),
      UNIQUE(file_path, repository_id, file_version)
  )
  ```

**Data Structures:**
```python
@dataclass
class DocumentSymbol:
    name: str
    kind: SymbolKind
    range: Range  # start/end positions
    selection_range: Range  # name location
    detail: str | None
    children: list['DocumentSymbol']
    parent_id: int | None = None
```

**Caching Strategy:**
- Cache by file_path + file_version (git hash or mtime)
- Invalidate on file changes detected via LSP didChange notifications
- Use existing SQLite WAL mode for concurrent reads

### 3. Implementation Plan

**New Files:**
- `document_symbol_cache.py` - Manages symbol hierarchy caching

**Files to Modify:**

1. **simple_lsp_client.py** - Add method:
   ```python
   async def get_document_symbols(
       self, file_uri: str, timeout: float = 10.0
   ) -> list[dict[str, Any]]
   ```

2. **codebase_tools.py:61** - Add to TOOL_HANDLERS:
   ```python
   "get_document_symbols": "get_document_symbols"
   ```

3. **symbol_storage.py:330** - Extend create_schema():
   - Add document_symbols table
   - Add indexes for file_path, repository_id, parent_id

4. **symbol_storage.py:88** - Add to AbstractSymbolStorage:
   ```python
   @abstractmethod
   def store_document_symbols(self, file_path: str, repository_id: str, 
                             symbols: list[DocumentSymbol], version: str) -> None
   
   @abstractmethod
   def get_document_symbols(self, file_path: str, repository_id: str) -> list[DocumentSymbol] | None
   ```

### 4. Architecture Patterns

**Apply Existing Patterns:**

1. **Abstract Factory Pattern** (already established):
   - Create `AbstractDocumentSymbolCache` interface
   - Implement `SQLiteDocumentSymbolCache` following `SQLiteSymbolStorage` pattern

2. **Template Method Pattern** from `symbol_storage.py:281`:
   - Reuse `_execute_with_retry` for all document symbol operations
   - Follow same retry/recovery approach

3. **Subprocess Management** from `simple_lsp_client.py:165-254`:
   - Copy exact cleanup pattern to prevent hanging processes
   - Use same timeout and error handling approach

4. **Repository Pattern**:
   - Keep all document symbol DB operations in storage layer
   - Business logic stays in CodebaseTools

**Error Handling:**
- Follow existing resilience patterns from `symbol_storage.py:233-258`
- Graceful fallback: If cache miss, fetch from LSP and store
- Handle LSP server unavailability by returning cached data if available

**Configuration Management:**
- Add `enable_document_symbol_cache` to repository config
- Default cache TTL: 1 hour (configurable)
- Max cache size per repository: 100MB

**Integration Points:**
- Hook into existing MCP worker initialization at `mcp_worker.py:186-200`
- Register tool handler via existing TOOL_HANDLERS mechanism
- Use production symbol storage instance already created

This architecture ensures:
- Consistent design patterns across the codebase
- Minimal disruption to existing functionality
- Scalable caching for large repositories
- Clear separation of concerns following established patterns

---
*This analysis was generated by the architect agent as part of the multi-agent workflow.*
